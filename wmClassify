#!/usr/bin/env groovy

import durbin.weka.* 
import durbin.util.*
import weka.core.converters.ConverterUtils.DataSource;
import weka.core.*

err = System.err // sugar

WekaAdditions.enable()

// Get the command line options, print help if needed. 
options = ParseOptions(args)

err.print "Reading model ${options.modelFile} ..."
model = (WekaMineModel) weka.core.SerializationHelper.read(options.modelFile);
err.println "done."

// Read the data (expression, CNV, whatever) and the clinical from tab delimited files
//instances = WekaMine.readFromTable(options.data)
instances = WekaMine.readNumericFromTable(options.data)

// Apply unsupervised filter
// KJD This function expects there to be an ID 
if (model.filter == null){
	err.println "No pre-processing filter specified in model."
}else{
	err.println "Applying filter: "+model.filter.class
	instances = WekaMine.applyUnsupervisedFilter(instances,model.filter)	
}

def className
if (options.className) className = options.className
else className = model.className

def holdoutClassName
if (options.holdoutClassName) holdoutClassName = options.holdoutClassName
else if (options.className) holdoutClassName = options.className
else className = model.className

err.println "className set: $className"
err.println "model.className: ${model.className}"
err.println "holdout className: ${holdoutClassName}"

if (options.holdoutSet){
	
	err.println "Holdout keys: "+options.holdoutSet.keySet()
	
	
	holdoutForClass = options.holdoutSet[holdoutClassName]
	err.println holdoutForClass
	err.print "Removing ALL except ${holdoutForClass.size()} holdout samples for ${holdoutClassName}..."
	err.print "before ${instances.numInstances()}..."
	instances = WekaMine.subsetInstances(instances,holdoutForClass)
	err.println "done. After: ${instances.numInstances()}"
}

	
// Create a new set of instances that match the model shis may mean removing
// some attributes that are not in the model and/or adding some that are in the model 
// but not in the data (set as missing values in this case).   Performance on datasets
// with different attribute sets will vary with algorithm and problem, but wekaMineClassify
// will attempt to apply the model to any dataset it is given. 

// The raw instances will, if nothing else,probably not be attribute selected, so a minimal
// effect of this will be to reduce the number of attributes significantly down to the 
// attribute selected subset of the model...

// The model has no ID, so we save the ID for later reporting...
instanceIDs = instances.attributeValues("ID") as ArrayList

//err.println "instanceIDs.size() = "+instanceIDs.size()

//err.println "model.attributes.size = "+model.attributes.size()

//instances = WekaMine.createInstancesToMatchAttributeList(instances,model.attributes)  // 17 seconds
//err.println "model.attributes:"+model.attributes
instances = InstanceUtils.createInstancesToMatchAttributeList(instances,model.attributes) // 3-5 seconds. 

// Since the model doesn't have an ID attribute, instances will not have an ID attribute after
// this matching exercise...
names = instances.attributeNames()

err.println "Model Attribute Names:"
err.println names

// Add an empty class attribute so that classifiers don't choke ?
instances = WekaMine.createEmptyClassAttribute(instances,className,model.classValues)
instances.setClassName(className)

// If a clinical file is given, also output whether or not the prediction matches
// the clinical value...
if (options.clinical){
	clinical = WekaMine.readFromTable(options.clinical)

		// Remove instances with missing class value...
	clinical.setClassName(className)

	// Remove instances with negative class value. 
	//clinical = WekaMine.cleanUpInstances(clinical)

	// Discretize the class attribute... (KJD... this should always be an explicit cutoff derived from experiment...)
	(clinical,clinicalCutoffs) = WekaMine.discretizeClassAttribute(clinical,model.discretization,className)			
							
	err.println "clinicalCutoffs: $clinicalCutoffs" 																												
}

// Model knows everything else needed to process the data... so have at it...
ArrayList<Classification> results = model.classify(instances)


def out = System.out
if (options.outputFile) {
	out = newOverwrite(options.outputFile)	
}

if (options.clinical){
	model.printResultsAndCompare(out,results,instanceIDs,clinical)				
}else{
	model.printResults(out,results,instanceIDs)
}



/****************************************************
* Parse the command line options, checking validity, printing help if needed. 
*/ 
def ParseOptions(args){
	parser = new Parser(description: '''
	
	wekaMineClassify reads in a saved wekaMine model file (.wmm) and a data file, 
	creates a set of instances from data file that match the model attributes, 
	creating missing attribute values where needed, and then applies the classifier to these 
	instances.  The output is one result per line with the instance ID followed by the probabilities
	of each class in a list.  If a clinical file is given, the clinical values are compared 
	with the predictions and summary statistics reported on the performance of the classifier. 
	 
	Written by: James Durbin (kdurbin@ucsc.edu)

	Example:


	''');

	parser.with{
		
		required 'm','modelFile',[description: 'wekaMine model file.']
	  required 'd','data', [description: 'Data file in attribute (row) by samples (col) format.']

		optional 'o','outputFile',[description: 'Output file.  If none given, output goes to stdout.']
	  optional 'i','clinical', [description: 'Clinical file in attribute (row) by samples (col) format.']
				
		optional 'c','className',[description: 'Specify name of class in clinical file (default takes class name from model).']		
		optional 'C','holdoutClassName',[description: 'Holdout class name (if different from -c).']		
		optional 'S','holdoutSet',[default:null,description: "Only classify samples in holdout file. Holdout samples indexed by className. All other samples will be excluded from analysis.",
		validate:{
			if (it != null){				
				// Read in the samplesToOmit... 
				samplesToOmitByClassAttribute = [:]
				new File(it).splitEachLine("\t"){fields->
					classAttr = fields[0]
					samplesToOmit = fields[1..-1]
					samplesToOmitByClassAttribute[classAttr] = samplesToOmit
				}
				return(samplesToOmitByClassAttribute)
			}else {
				return(it)							
			}
		}
	]
		
	  flag 'h','help',[default:false,description: 'Print script help.']
	}

	def options
	try{
	  options = parser.parse(args)
		//if (options.clinical){
		//	err.println "DISABLED.  Matching to clinical has some bug.  Until it's fixed, the -i option is disabled."
		//	System.exit(1)
		//}
	}catch(Exception e){
	  System.err << parser.usage
	  System.exit(1)
	}	
	
	return(options)
}

def newOverwrite(fileName){
	f = new File(fileName)
	if (f.exists()){
		f.delete()
		f.createNewFile()
	}
	return(f)
}

